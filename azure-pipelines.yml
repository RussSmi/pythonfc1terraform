# Azure DevOps Pipeline for Python Function App with Terraform
# This pipeline deploys infrastructure via Terraform and then deploys the Python function code
name: deploy-function-app

trigger:
  branches:
    include:
    - main
  paths:
    include:
    - '**'

variables:
  # Terraform Configuration
  terraformVersion: 'Latest'
  terraformWorkingDirectory: '$(System.DefaultWorkingDirectory)'
  
  # Azure Configuration

  
  # Function App Configuration
  pythonVersion: '3.12'
  functionAppName: 'python-fn-demo' # This should match your fa_name in rgs.tfvars
  
  # Environment specific variables
  ${{ if eq(variables['Build.SourceBranch'], 'refs/heads/main') }}:
    environment: 'production'
    resourceGroupName: 'rg-python-fn-uks'
  ${{ else }}:
    environment: 'development'
    resourceGroupName: 'rg-python-fn-uks-dev'

stages:
- stage: ValidateAndPlan
  displayName: 'Validate and Plan Infrastructure'
  jobs:
  - job: TerraformValidate
    displayName: 'Terraform Validate and Plan'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - checkout: self
      displayName: 'Checkout Repository'
    
    - task: TerraformInstaller@1
      displayName: 'Install Terraform'
      inputs:
        terraformVersion: $(terraformVersion)
    
    - task: TerraformTaskV4@4
      displayName: 'Terraform Init and Validate'
      inputs:
        provider: 'azurerm'
        command: 'init'
        workingDirectory: '$(terraformWorkingDirectory)'
        backendServiceArm: 'azureServiceConnection'
        backendAzureRmResourceGroupName: 'rg-tfstate-uks'
        backendAzureRmStorageAccountName: 'tfstateelpy7eogzws7x'
        backendAzureRmContainerName: 'pythonfc1terraform'
        backendAzureRmKey: 'terraform-non-prod.tfstate'

    - task: TerraformTaskV4@4
      displayName: 'Terraform Validate'
      inputs:
        provider: 'azurerm'
        command: 'validate'
        workingDirectory: '$(terraformWorkingDirectory)'

    - task: TerraformTaskV4@4
      displayName: 'Terraform Plan'
      inputs:
        provider: 'azurerm'
        command: 'plan'
        workingDirectory: '$(terraformWorkingDirectory)'
        environmentServiceNameAzureRM: 'azureServiceConnection'
        commandOptions: '-var-file=rgs.tfvars -out=tfplan'
    
    - task: PublishPipelineArtifact@1
      displayName: 'Publish Terraform Plan'
      inputs:
        targetPath: '$(terraformWorkingDirectory)/tfplan'
        artifact: 'terraform-plan'

- stage: DeployInfrastructure
  displayName: 'Deploy Infrastructure'
  dependsOn: ValidateAndPlan
  condition: succeeded()
  jobs:
  - deployment: DeployTerraform
    displayName: 'Deploy Terraform Infrastructure'
    pool:
      vmImage: 'ubuntu-latest'
    environment: $(environment)
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self
            displayName: 'Checkout Repository'
          
          - task: DownloadPipelineArtifact@2
            displayName: 'Download Terraform Plan'
            inputs:
              artifactName: 'terraform-plan'
              downloadPath: '$(terraformWorkingDirectory)'
          
          - task: TerraformInstaller@1
            displayName: 'Install Terraform'
            inputs:
              terraformVersion: $(terraformVersion)
          
          - task: TerraformTaskV4@4
            displayName: 'Terraform Init'
            inputs:
              provider: 'azurerm'
              command: 'init'
              workingDirectory: '$(terraformWorkingDirectory)'
              backendServiceArm: 'azureServiceConnection'
              backendAzureRmResourceGroupName: 'rg-tfstate-uks'
              backendAzureRmStorageAccountName: 'tfstateelpy7eogzws7x'
              backendAzureRmContainerName: 'pythonfc1terraform'
              backendAzureRmKey: 'terraform-non-prod.tfstate'
          
          - task: TerraformTaskV4@4
            displayName: 'Terraform Apply'
            inputs:
              provider: 'azurerm'
              command: 'apply'
              workingDirectory: '$(terraformWorkingDirectory)'
              environmentServiceNameAzureRM: 'azureServiceConnection'
              commandOptions: 'tfplan'
            name: 'terraformApply'

- stage: BuildAndDeployFunction
  displayName: 'Build and Deploy Function App'
  dependsOn: DeployInfrastructure
  condition: succeeded()
  
  jobs:
  - job: BuildFunction
    displayName: 'Build Python Function'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - checkout: self
      displayName: 'Checkout Repository'
    
    - task: UsePythonVersion@0
      displayName: 'Use Python $(pythonVersion)'
      inputs:
        versionSpec: '$(pythonVersion)'
        addToPath: true
        architecture: 'x64'
    
    - script: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
      displayName: 'Install Python Dependencies'
    
    - script: |
        # Create deployment package excluding unnecessary files
        mkdir -p $(Build.ArtifactStagingDirectory)/function-package
        
        # Copy function files
        cp function_app.py $(Build.ArtifactStagingDirectory)/function-package/
        cp host.json $(Build.ArtifactStagingDirectory)/function-package/
        cp requirements.txt $(Build.ArtifactStagingDirectory)/function-package/
        
        # Copy any additional function files (if they exist)
        if [ -f "local.settings.json" ]; then
          cp local.settings.json $(Build.ArtifactStagingDirectory)/function-package/
        fi
        
        # Install production dependencies into the package
        pip install --target $(Build.ArtifactStagingDirectory)/function-package -r requirements.txt
        
        # Remove unnecessary files from the package
        find $(Build.ArtifactStagingDirectory)/function-package -name "*.pyc" -delete
        find $(Build.ArtifactStagingDirectory)/function-package -name "__pycache__" -type d -exec rm -rf {} + 2>/dev/null || true
        
        echo "Function package created successfully"
        ls -la $(Build.ArtifactStagingDirectory)/function-package/
      displayName: 'Create Deployment Package'
    
    - task: PublishPipelineArtifact@1
      displayName: 'Publish Function Package'
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)/function-package'
        artifact: 'function-package'

  - deployment: DeployFunction
    displayName: 'Deploy Function to Azure'
    dependsOn: BuildFunction
    pool:
      vmImage: 'ubuntu-latest'
    environment: $(environment)
    strategy:
      runOnce:
        deploy:
          steps:
          - task: DownloadPipelineArtifact@2
            displayName: 'Download Function Package'
            inputs:
              artifactName: 'function-package'
              downloadPath: '$(Pipeline.Workspace)/function-package'
          
          - task: AzureCLI@2
            displayName: 'Verify Function App and Deploy'
            inputs:
              azureSubscription: 'azureServiceConnection'
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                echo "Verifying Function App exists..."
                
                # Check if function app exists
                if az functionapp show --name $(functionAppName) --resource-group $(resourceGroupName) > /dev/null 2>&1; then
                  echo "✅ Function App '$(functionAppName)' found in resource group '$(resourceGroupName)'"
                  
                  # Get function app details
                  az functionapp show --name $(functionAppName) --resource-group $(resourceGroupName) --query "{name:name, state:state, kind:kind, sku:appServicePlanId}" -o table
                  
                  # Wait a bit for the function app to be fully ready
                  echo "Waiting 30 seconds for Function App to be fully ready..."
                  sleep 30
                  
                  # Create zip file for deployment
                  cd $(Pipeline.Workspace)/function-package
                  zip -r ../function-app.zip .
                  
                  echo "Deploying function app using Azure CLI..."
                  az functionapp deployment source config-zip \
                    --resource-group $(resourceGroupName) \
                    --name $(functionAppName) \
                    --src $(Pipeline.Workspace)/function-app.zip \
                    --verbose
                  
                  echo "✅ Function app deployed successfully"
                else
                  echo "❌ Function App '$(functionAppName)' not found in resource group '$(resourceGroupName)'"
                  echo "Available function apps in resource group:"
                  az functionapp list --resource-group $(resourceGroupName) --query "[].name" -o table
                  exit 1
                fi

- stage: PostDeploymentValidation
  displayName: 'Post-Deployment Validation'
  dependsOn: BuildAndDeployFunction
  condition: succeeded()
  
  jobs:
  - job: ValidateDeployment
    displayName: 'Validate Function Deployment'
    pool:
      vmImage: 'ubuntu-latest'
    
    steps:
    - task: AzureCLI@2
      displayName: 'Test Function Endpoint'
      inputs:
        azureSubscription: 'azureServiceConnection'
        scriptType: 'bash'
        scriptLocation: 'inlineScript'
        inlineScript: |
          # Get function app URL
          FUNCTION_URL=$(az functionapp show --name $(functionAppName) --resource-group $(resourceGroupName) --query "properties.defaultHostName" -o tsv)
          
          echo "Function App URL: $FUNCTION_URL"
          
          # Test the function endpoint
          echo "Testing function at: https://$FUNCTION_URL/api/httpexample"
          
          # Simple health check (might need function key for full test)
          response=$(curl -s -o /dev/null -w "%{http_code}" "https://$FUNCTION_URL/api/httpexample?name=Pipeline")
          
          if [ $response -eq 200 ] || [ $response -eq 401 ]; then
            echo "Function is responding (HTTP $response)"
            echo "##vso[task.complete result=Succeeded;]Function deployment validated successfully"
          else
            echo "Function is not responding correctly (HTTP $response)"
            echo "##vso[task.complete result=Failed;]Function deployment validation failed"
            exit 1
          fi
